# ICR 솔루션 개발자 매뉴얼

/toc

## 1. 개요

### 1-1. 배포 패키지 구조

설치 전 배포 패키지의 디렉토리 구조입니다.

```
icr-solution/
├── README.md                  # 빠른 시작 가이드
├── install.sh                 # 설치 실행 (래퍼)
├── uninstall.sh               # 제거 실행 (래퍼)
├── setup-permissions.sh       # 권한 복구 (Windows 작업 후)
├── logging.sh                 # 공통 로깅 모듈
│
├── docs/                      # 문서
│   ├── 01.ICR_솔루션_개발자_메뉴얼.pdf
│   ├── 02.ICR_솔루션_운영자_메뉴얼.pdf
│   └── 03.ICR_솔루션_명령어_모음.pdf
│
├── packages/                  # 설치 원본
│   ├── apache-tomcat-*.tar.gz # Tomcat 배포판
│   ├── JDK21_x64.tar.gz       # 번들 JDK (Intel/AMD, JAVA_SOURCE=bundled 시 필요)
│   ├── JDK21_arm.tar.gz       # 번들 JDK (ARM64, JAVA_SOURCE=bundled 시 필요)
│   └── icr.war                # 애플리케이션 WAR
│
└── solution/
    ├── bin/                   # 실행 스크립트
    │   ├── install-core.sh    # 설치 코어 로직
    │   ├── uninstall-core.sh  # 제거 코어 로직
    │   ├── start.sh           # 서비스 시작
    │   ├── stop.sh            # 서비스 중지
    │   ├── deploy-war.sh      # WAR 배포
    │   ├── check.sh           # 종합 점검
    │   ├── health.sh          # HTTP 헬스체크
    │   └── health-https.sh    # HTTPS 헬스체크
    │
    ├── config/                # 설정 파일
    │   └── site.conf          # [수정 대상] 환경 설정
    │
    ├── modules/               # 공통 모듈 (수정 불필요)
    │   ├── logging.sh         # 로깅 함수 (log, die, init_logging)
    │   └── service_control.sh # start/stop 공통 함수
    │
    ├── logs/                  # 스크립트 실행 로그
    │   └── {script}-{YYYYMMDD}.log
    │
    └── templates/             # 설정 템플릿 (수정 불필요)
        └── tomcat/
            ├── server.xml.tpl     # @TOKEN@ 치환 → server.xml
            ├── web.xml.tpl        # @TOKEN@ 치환 → web.xml
            ├── context.xml.tpl    # @TOKEN@ 치환 → context.xml
            └── setenv.sh.tpl      # @TOKEN@ 치환 → setenv.sh
```

### 1-2. 설정 흐름

```
site.conf (원본 설정)
    ↓ install.sh 실행
templates/*.tpl (@TOKEN@ 치환)
    ↓
$INSTALL_BASE/config/tomcat/* (실제 설정 파일)
    ↓ 심볼릭 링크
$TOMCAT_HOME/conf/*, $TOMCAT_HOME/bin/setenv.sh
```

### 1-3. 설치 후 디렉토리 구조

설치 완료 후 INSTALL_BASE(기본: /opt/icr-solution)에 생성되는 구조입니다.

```
/opt/icr-solution/              # INSTALL_BASE
├── tomcat -> apache-tomcat-*   # TOMCAT_HOME (심볼릭 링크)
│
├── apache-tomcat-10.1.50/      # Tomcat 실제 디렉토리
│   ├── bin/
│   │   └── setenv.sh -> ../../config/tomcat/setenv.sh
│   ├── conf/
│   │   ├── server.xml -> ../../config/tomcat/server.xml
│   │   ├── web.xml -> ../../config/tomcat/web.xml
│   │   └── context.xml -> ../../config/tomcat/context.xml
│   ├── logs/                   # Tomcat 로그 (catalina.out 등)
│   └── icr-webapps/            # WAS_APP_BASE (WAR 배포 디렉토리)
│       └── ROOT/               # 압축 해제된 애플리케이션
│
├── java -> jdk-21.0.9+10       # Java 심볼릭 링크 (JAVA_SOURCE=bundled 시)
├── jdk-21.0.9+10/              # 번들 JDK 디렉토리 (JAVA_SOURCE=bundled 시)
│
├── config/
│   └── tomcat/                 # 실제 설정 파일 (여기를 수정)
│       ├── server.xml          # Tomcat 서버 설정
│       ├── web.xml             # 웹 애플리케이션 설정
│       ├── context.xml         # 컨텍스트 설정
│       └── setenv.sh           # JVM 환경 변수
│
├── backup/
│   └── war/                    # WAR 백업 (deploy-war.sh 사용 시)
│
├── logs/                       # 애플리케이션 로그 (Logback ICR_LOG_PATH)
└── data/                       # 데이터 디렉토리 (예약)
```

> **참고**: `JAVA_SOURCE=bundled` 설정 시에만 `java/`, `jdk-21.0.9+10/` 디렉토리가 생성됩니다.

### 1-4. 설정 파일 위치

설치 후 생성되는 설정 파일 위치입니다.

| 파일 | 위치 | 용도 |
|------|------|------|
| site.conf | solution/config/site.conf | 설치 설정 (원본) |
| server.xml | $INSTALL_BASE/config/tomcat/server.xml | Tomcat 서버 설정 |
| web.xml | $INSTALL_BASE/config/tomcat/web.xml | 웹 애플리케이션 설정 |
| context.xml | $INSTALL_BASE/config/tomcat/context.xml | 컨텍스트 설정 |
| setenv.sh | $INSTALL_BASE/config/tomcat/setenv.sh | JVM 환경 변수 |

설정 파일은 `$INSTALL_BASE/config/tomcat/`에 생성되고, Tomcat의 `conf/`, `bin/` 디렉토리에 심볼릭 링크로 연결됩니다.


## 2. site.conf 설정

### 2-1. 필수 설정 항목

반드시 사이트 환경에 맞게 수정해야 하는 항목입니다.

```bash
# 사이트 식별자
# - 로그, 모니터링에서 인스턴스 구분용
SITE=INFODEA

# Spring Boot 프로파일
# - application.yml에서 적용할 프로파일
ENV=prod

# Java 소스 선택
# - system: 시스템에 설치된 JDK 사용 (JAVA_HOME 필수)
# - bundled: packages/의 번들 JDK 자동 설치 (JAVA_HOME 자동 설정)
JAVA_SOURCE=system

# Java 홈 경로 (JAVA_SOURCE=system 일 때 필수)
# - 서버에 설치된 JDK 경로
JAVA_HOME=/usr/lib/jvm/temurin-21

# HTTP 포트
# - 웹 애플리케이션 접속 포트
WAS_HTTP_PORT=28080

# Jasypt 암호화 키
# - application.yml 암호화된 값 복호화용
JASYPT_ENCRYPTOR_PASSWORD=your_secret_key
```

### 2-1-1. 번들 JDK 상세

`JAVA_SOURCE=bundled` 설정 시 packages/ 디렉토리의 JDK 아카이브가 자동 설치됩니다.

**아키텍처 자동 감지:**

설치 스크립트가 서버 아키텍처를 자동 감지하여 적절한 JDK 파일을 선택합니다.

| 아키텍처 | 감지 조건 | 필요 파일 |
|---------|----------|----------|
| x64 (AMD64) | `uname -m` = x86_64 | `packages/JDK21_x64.tar.gz` |
| ARM64 (AArch64) | `uname -m` = aarch64 | `packages/JDK21_arm.tar.gz` |

**설치 후 디렉토리 구조:**

```
$INSTALL_BASE/
├── java -> jdk-21.0.9+10       # 심볼릭 링크 (JAVA_HOME 자동 설정)
└── jdk-21.0.9+10/              # 실제 JDK 디렉토리
    ├── bin/
    ├── lib/
    └── ...
```

**동작 방식:**

1. 서버 아키텍처 감지 (`uname -m`)
2. 해당 아키텍처의 JDK 아카이브 선택
3. `$INSTALL_BASE/`에 압축 해제
4. `$INSTALL_BASE/java` 심볼릭 링크 생성
5. JAVA_HOME 자동 설정 (`$INSTALL_BASE/java`)
6. setenv.sh에 자동 반영

**사용 시나리오:**

- **폐쇄망 환경**: 외부 패키지 저장소 접근 불가 시
- **버전 통일**: 모든 서버에서 동일한 JDK 버전 보장
- **의존성 최소화**: 시스템 JDK 설치 불필요

> **주의:** bundled 사용 시 site.conf의 `JAVA_HOME` 값은 무시되고 자동 설정됩니다.

### 2-2. 선택 설정 항목

기본값으로 사용 가능하나, 필요시 변경하는 항목입니다.

```bash
# 설치 기본 경로
INSTALL_BASE=/opt/icr-solution

# Tomcat 심볼릭 링크 경로
TOMCAT_HOME=/opt/icr-solution/tomcat

# Tomcat 배포판 이름
TOMCAT_DIST_NAME=apache-tomcat-10.1.50

# 앱 배포 디렉토리 (TOMCAT_HOME 기준 상대경로)
WAS_APP_BASE=icr-webapps

# HTTPS 포트
WAS_HTTPS_PORT=28443

# HTTPS 활성화 여부
WAS_ENABLE_HTTPS=Y

# 외부 설정 디렉토리
ICR_CONFIG_DIR=/opt/icr-solution/config

# JVM 힙 메모리
JVM_XMS=512m
JVM_XMX=1024m

# 타임존
JVM_TIMEZONE=Asia/Seoul

# 파일 인코딩
JVM_ENCODING=UTF-8
```

### 2-3. 고급 설정 항목

특수 상황에서만 변경하는 항목입니다.

```bash
# Tomcat Shutdown 포트
# - 동일 서버 다중 인스턴스 시 변경 필요
WAS_SHUTDOWN_PORT=8005

# SSL 인증서 파일명
# - HTTPS 사용 시 $TOMCAT_HOME/conf/ 에 위치
WAS_SSL_KEYSTORE_FILE=localhost-rsa.jks

# SSL 인증서 비밀번호
WAS_SSL_KEYSTORE_PASSWORD=changeit

# 서비스 타임아웃 설정
SVC_START_TIMEOUT_SEC=30
SVC_STOP_TIMEOUT_SEC=30
SVC_STOP_FORCEKILL=Y
SVC_STOP_FORCEKILL_GRACE_SEC=1
```

### 2-4. 템플릿 플레이스홀더 목록

설치 시 템플릿 파일의 `@TOKEN@` 플레이스홀더가 site.conf 값으로 치환됩니다.

**setenv.sh.tpl (JVM 환경 설정):**

| 플레이스홀더 | site.conf 변수 | 설명 |
|-------------|---------------|------|
| `@JAVA_HOME@` | JAVA_HOME | Java 설치 경로 |
| `@JVM_XMS@` | JVM_XMS | 초기 힙 메모리 |
| `@JVM_XMX@` | JVM_XMX | 최대 힙 메모리 |
| `@JVM_ENCODING@` | JVM_ENCODING | 파일 인코딩 (기본: UTF-8) |
| `@JVM_TIMEZONE@` | JVM_TIMEZONE | 타임존 (기본: Asia/Seoul) |
| `@ENV@` | ENV | Spring 프로파일 |
| `@SITE@` | SITE | 사이트 식별자 |
| `@ICR_CONFIG_DIR@` | ICR_CONFIG_DIR | 외부 설정 디렉토리 |
| `@INSTALL_BASE@` | INSTALL_BASE | 설치 기본 경로 |
| `@JASYPT_ENCRYPTOR_PASSWORD@` | JASYPT_ENCRYPTOR_PASSWORD | Jasypt 암호화 키 |

**server.xml.tpl (Tomcat 서버 설정):**

| 플레이스홀더 | site.conf 변수 | 설명 |
|-------------|---------------|------|
| `@WAS_SHUTDOWN_PORT@` | WAS_SHUTDOWN_PORT | Tomcat 종료 포트 |
| `@WAS_HTTP_PORT@` | WAS_HTTP_PORT | HTTP 커넥터 포트 |
| `@WAS_HTTPS_PORT@` | WAS_HTTPS_PORT | HTTPS 커넥터 포트 |
| `@WAS_APP_BASE@` | WAS_APP_BASE | 앱 배포 디렉토리 |
| `@WAS_SSL_KEYSTORE_FILE@` | WAS_SSL_KEYSTORE_FILE | SSL 인증서 파일명 |
| `@WAS_SSL_KEYSTORE_PASSWORD@` | WAS_SSL_KEYSTORE_PASSWORD | SSL 인증서 비밀번호 |

> **참고:** web.xml.tpl, context.xml.tpl은 플레이스홀더 없이 그대로 복사됩니다.

### 2-5. ICR_FORCE_REGEN 환경변수

설정 파일 재생성 동작을 제어합니다.

**동작 방식:**

```
파일 없음 → 새로 생성
파일 있음 + ICR_FORCE_REGEN=N → 기존 유지 (기본)
파일 있음 + ICR_FORCE_REGEN=Y → 백업 후 재생성
```

**적용 대상 파일:**
- `$INSTALL_BASE/config/tomcat/server.xml`
- `$INSTALL_BASE/config/tomcat/web.xml`
- `$INSTALL_BASE/config/tomcat/context.xml`
- `$INSTALL_BASE/config/tomcat/setenv.sh`
- `$TOMCAT_HOME/$WAS_APP_BASE/icr.war`

**백업 파일명 형식:**
```
{파일명}.bak.YYYYMMDD_HHMMSS
예: server.xml.bak.20250115_143022
```

**사용 예시:**
```bash
# 기본 설치 (기존 설정 유지)
./install.sh

# 설정 강제 재생성 (site.conf 변경 후)
ICR_FORCE_REGEN=Y ./install.sh
```


## 3. 환경별 설정 예시

### 3-1. 개발 환경 (dev)

개발 환경에서 권장하는 설정입니다.

```bash
# ═══════════════════════════════════════════════
# 개발 환경 설정 예시
# ═══════════════════════════════════════════════

# 사이트 식별
SITE=DEV_LOCAL
ENV=dev

# Java 설정 (개발 환경: 시스템 JDK 사용)
JAVA_SOURCE=system
JAVA_HOME=/usr/lib/jvm/temurin-21

# 경로
INSTALL_BASE=/opt/icr-solution
TOMCAT_HOME=/opt/icr-solution/tomcat

# 포트 (개발 환경 기본)
WAS_HTTP_PORT=8080
WAS_HTTPS_PORT=8443
WAS_SHUTDOWN_PORT=8005

# HTTPS (개발환경에서는 비활성화 가능)
WAS_ENABLE_HTTPS=N

# JVM (개발환경은 낮게 설정)
JVM_XMS=256m
JVM_XMX=512m

# Jasypt 키 (개발용)
JASYPT_ENCRYPTOR_PASSWORD=dev_secret_key
```

### 3-2. 스테이징 환경 (staging)

스테이징 환경에서 권장하는 설정입니다.

```bash
# ═══════════════════════════════════════════════
# 스테이징 환경 설정 예시
# ═══════════════════════════════════════════════

# 사이트 식별
SITE=STAGING
ENV=staging

# Java 설정 (스테이징: 시스템 JDK 또는 번들 선택)
JAVA_SOURCE=system
JAVA_HOME=/usr/lib/jvm/temurin-21

# 경로
INSTALL_BASE=/opt/icr-solution
TOMCAT_HOME=/opt/icr-solution/tomcat

# 포트 (운영과 동일하게)
WAS_HTTP_PORT=28080
WAS_HTTPS_PORT=28443
WAS_SHUTDOWN_PORT=8005

# HTTPS (운영과 동일하게 활성화)
WAS_ENABLE_HTTPS=Y
WAS_SSL_KEYSTORE_FILE=staging-cert.jks
WAS_SSL_KEYSTORE_PASSWORD=staging_password

# JVM (운영과 유사하게)
JVM_XMS=512m
JVM_XMX=1024m

# Jasypt 키
JASYPT_ENCRYPTOR_PASSWORD=staging_secret_key
```

### 3-3. 운영 환경 (prod)

운영 환경에서 권장하는 설정입니다.

```bash
# ═══════════════════════════════════════════════
# 운영 환경 설정 예시
# ═══════════════════════════════════════════════

# 사이트 식별
SITE=PRODUCTION
ENV=prod

# Java 설정 (운영/폐쇄망: 번들 JDK 권장)
JAVA_SOURCE=bundled
# JAVA_HOME은 자동 설정됨

# 경로
INSTALL_BASE=/opt/icr-solution
TOMCAT_HOME=/opt/icr-solution/tomcat

# 포트
WAS_HTTP_PORT=28080
WAS_HTTPS_PORT=28443
WAS_SHUTDOWN_PORT=8005

# HTTPS (운영에서는 필수)
WAS_ENABLE_HTTPS=Y
WAS_SSL_KEYSTORE_FILE=production-cert.jks
WAS_SSL_KEYSTORE_PASSWORD=production_secure_password

# JVM (서버 메모리에 따라 조정)
JVM_XMS=2g
JVM_XMX=4g

# Jasypt 키 (운영용 별도 관리)
JASYPT_ENCRYPTOR_PASSWORD=production_secret_key
```


## 4. HTTPS 설정

### 4-1. 인증서 준비

HTTPS 사용을 위해 SSL 인증서가 필요합니다.

**JKS 형식 인증서 준비:**

```bash
# PEM을 JKS로 변환 (기존 인증서가 있는 경우)
openssl pkcs12 -export -in certificate.crt -inkey private.key \
    -out certificate.p12 -name tomcat

keytool -importkeystore -srckeystore certificate.p12 \
    -srcstoretype PKCS12 -destkeystore certificate.jks \
    -deststoretype JKS
```

**자체 서명 인증서 생성 (테스트용):**

```bash
keytool -genkeypair -alias tomcat -keyalg RSA -keysize 2048 \
    -validity 365 -keystore test-cert.jks \
    -dname "CN=localhost, OU=Test, O=Test, L=Seoul, ST=Seoul, C=KR"
```

### 4-2. site.conf 설정

인증서 파일을 Tomcat conf 디렉토리에 복사하고 site.conf를 설정합니다.

```bash
# 인증서 파일 복사
cp certificate.jks /opt/icr-solution/tomcat/conf/

# site.conf 설정
WAS_ENABLE_HTTPS=Y
WAS_SSL_KEYSTORE_FILE=certificate.jks
WAS_SSL_KEYSTORE_PASSWORD=your_keystore_password
```

설정 변경 후 서비스를 재시작합니다.

```bash
./solution/bin/stop.sh
./solution/bin/start.sh
```

### 4-3. 인증서 갱신

인증서 만료 시 갱신 절차입니다.

```bash
# 1. 새 인증서 파일 복사
cp new-certificate.jks /opt/icr-solution/tomcat/conf/

# 2. site.conf 수정 (파일명이 변경된 경우)
vi solution/config/site.conf
# WAS_SSL_KEYSTORE_FILE=new-certificate.jks

# 3. 설정 재생성 및 재시작
ICR_FORCE_REGEN=Y ./install.sh
./solution/bin/stop.sh
./solution/bin/start.sh

# 4. HTTPS 헬스체크
./solution/bin/health-https.sh --verify
```

### 4-4. 에러 페이지 매핑

web.xml.tpl에 정의된 HTTP 에러 코드별 커스텀 에러 페이지 매핑입니다.

**기본 에러 페이지 매핑:**

| HTTP 코드 | 설명 | 에러 페이지 경로 |
|-----------|------|-----------------|
| 400 | Bad Request | `/WEB-INF/classes/static/html/error/400.html` |
| 401 | Unauthorized | `/WEB-INF/classes/static/html/error/401.html` |
| 402 | Payment Required | `/WEB-INF/classes/static/html/error/402.html` |
| 403 | Forbidden | `/WEB-INF/classes/static/html/error/403.html` |
| 404 | Not Found | `/WEB-INF/classes/static/html/error/404.html` |
| 500 | Internal Server Error | `/WEB-INF/classes/static/html/error/500.html` |

**경로 구조:**

```
WAR 파일 (icr.war)
└── WEB-INF/
    └── classes/
        └── static/
            └── html/
                └── error/
                    ├── 400.html
                    ├── 401.html
                    ├── 402.html
                    ├── 403.html
                    ├── 404.html
                    └── 500.html
```

이 경로는 Spring Boot의 정적 리소스 구조를 따릅니다.

- Spring Boot에서 `src/main/resources/static/html/error/` 에 파일 생성
- 빌드 시 WAR 내 `/WEB-INF/classes/static/html/error/` 로 패키징

**커스터마이징:**

에러 페이지 디자인을 변경하려면:

1. Spring Boot 프로젝트에서 `src/main/resources/static/html/error/*.html` 수정
2. WAR 재빌드 및 배포
3. Tomcat web.xml은 수정 불필요 (경로 동일)

> **참고:** Spring Boot `ErrorController`와 Tomcat 에러 페이지가 충돌할 수 있습니다.
> ICR 솔루션은 Tomcat 레벨에서 처리하여 Spring Boot 로딩 전 에러도 커버합니다.

### 4-5. web.xml 인코딩 설정

web.xml.tpl에는 UTF-8 인코딩을 보장하기 위한 설정이 포함되어 있습니다.

**1. 전역 인코딩 선언 (Servlet 4.0+ 표준):**

```xml
<request-character-encoding>UTF-8</request-character-encoding>
<response-character-encoding>UTF-8</response-character-encoding>
```

Servlet 4.0+ 표준 방식으로 요청/응답 기본 인코딩을 선언합니다.

**2. SetCharacterEncodingFilter:**

```xml
<filter>
    <filter-name>encodingFilter</filter-name>
    <filter-class>org.apache.catalina.filters.SetCharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
    <init-param>
        <!-- ignore=false: 기존 인코딩이 있어도 UTF-8로 강제 -->
        <param-name>ignore</param-name>
        <param-value>false</param-value>
    </init-param>
</filter>

<filter-mapping>
    <filter-name>encodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

**주요 파라미터:**

| 파라미터 | 값 | 설명 |
|---------|-----|------|
| `encoding` | UTF-8 | 적용할 문자 인코딩 |
| `ignore` | false | false: 기존 인코딩 무시하고 강제 적용<br>true: 기존 인코딩이 있으면 유지 |

**적용 범위:**
- 모든 요청 (`/*`)에 UTF-8 인코딩 적용
- POST 파라미터, 폼 데이터 등 한글 깨짐 방지
- Spring의 CharacterEncodingFilter와 유사한 역할

> **참고:** Spring Boot와 함께 사용 시, Spring의 `CharacterEncodingFilter`보다 먼저 실행됩니다.
> 둘 다 UTF-8로 설정되어 있으면 충돌 없이 동작합니다.

### 4-6. RemoteIpValve 설정 (리버스 프록시)

server.xml.tpl에는 리버스 프록시(L4/L7/Nginx) 환경에서 실제 클라이언트 IP를 식별하기 위한 RemoteIpValve가 설정되어 있습니다.

**기본 설정:**

```xml
<Valve className="org.apache.catalina.valves.RemoteIpValve"
       remoteIpHeader="x-forwarded-for"
       protocolHeader="x-forwarded-proto"
       portHeader="x-forwarded-port"
       requestAttributesEnabled="true"
       internalProxies=""
       httpsServerPort="443" />
```

**주요 속성:**

| 속성 | 기본값 | 설명 |
|------|-------|------|
| `remoteIpHeader` | x-forwarded-for | 실제 클라이언트 IP가 담긴 헤더 |
| `protocolHeader` | x-forwarded-proto | 원본 프로토콜(http/https) 헤더 |
| `portHeader` | x-forwarded-port | 원본 포트 헤더 |
| `requestAttributesEnabled` | true | request 속성에 원본 정보 저장 |
| `internalProxies` | (비어있음) | 신뢰할 내부 프록시 IP 대역 (정규식) |
| `httpsServerPort` | 443 | HTTPS 기본 포트 |

**동작 방식:**

```
[클라이언트] → [Nginx/L7] → [Tomcat]
   1.2.3.4       10.0.0.1     request.getRemoteAddr()

   x-forwarded-for: 1.2.3.4   → RemoteIpValve가 처리
                              → request.getRemoteAddr() = 1.2.3.4
```

**보안 설정 (internalProxies):**

프록시 IP 대역을 제한하여 헤더 스푸핑을 방지합니다.

```xml
<!-- 내부 네트워크만 신뢰 (예시) -->
<Valve className="org.apache.catalina.valves.RemoteIpValve"
       remoteIpHeader="x-forwarded-for"
       protocolHeader="x-forwarded-proto"
       internalProxies="10\.0\.0\.\d{1,3}|192\.168\.\d{1,3}\.\d{1,3}" />
```

**Spring Boot 연동:**

RemoteIpValve가 처리한 후 Spring에서 사용 가능합니다:

```java
// 실제 클라이언트 IP 조회
String clientIp = request.getRemoteAddr();  // RemoteIpValve가 변환한 값

// 원본 프로토콜 확인
boolean isSecure = request.isSecure();  // x-forwarded-proto 기반
```

> **주의:** `internalProxies`가 비어있으면 모든 IP의 x-forwarded-for 헤더를 신뢰합니다.
> 운영 환경에서는 프록시 서버 IP 대역을 명시적으로 설정하는 것을 권장합니다.


## 5. JVM 튜닝

### 5-1. 메모리 설정

서버 가용 메모리에 따라 힙 메모리를 조정합니다.

| 서버 메모리 | JVM_XMS | JVM_XMX |
|-------------|---------|---------|
| 4GB | 512m | 1g |
| 8GB | 1g | 2g |
| 16GB | 2g | 4g |
| 32GB | 4g | 8g |

```bash
# site.conf 설정
JVM_XMS=2g
JVM_XMX=4g
```

**메모리 설정 원칙:**
- XMS와 XMX는 동일하게 설정하는 것을 권장
- 서버 가용 메모리의 50~70%를 XMX로 설정
- 나머지는 OS와 기타 프로세스용으로 확보

### 5-2. GC 설정

Java 21 이상에서는 G1GC가 기본입니다. 추가 튜닝이 필요한 경우 setenv.sh.tpl을 수정합니다.

**setenv.sh.tpl에 GC 옵션 추가:**

```bash
# GC 설정 (Java 21+에서는 G1GC가 기본)
export JAVA_OPTS="$JAVA_OPTS -XX:+UseG1GC"
export JAVA_OPTS="$JAVA_OPTS -XX:MaxGCPauseMillis=200"

# GC 로그 (Java 21+ 형식)
export JAVA_OPTS="$JAVA_OPTS -Xlog:gc*:file=${CATALINA_HOME}/logs/gc.log:time,uptime:filecount=5,filesize=10M"

# 힙 덤프 (OOM 발생 시 자동 생성)
export JAVA_OPTS="$JAVA_OPTS -XX:+HeapDumpOnOutOfMemoryError"
export JAVA_OPTS="$JAVA_OPTS -XX:HeapDumpPath=${CATALINA_HOME}/logs/"
```

### 5-3. 디버그 모드

원격 디버깅이 필요한 경우 설정합니다.

**setenv.sh.tpl에 디버그 옵션 추가:**

```bash
# 디버그 모드 (개발환경 전용)
export JAVA_OPTS="$JAVA_OPTS -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005"
```

**IDE에서 원격 디버그 연결:**
- Host: 서버 IP
- Port: 5005
- Transport: Socket

### 5-4. 로그 디렉토리 설정

애플리케이션 로그(Logback)는 기본적으로 `$INSTALL_BASE/logs/`에 저장됩니다.

**setenv.sh에서 설정되는 JVM 프로퍼티:**

```bash
# 설치 시 자동 생성되는 setenv.sh
# ICR_LOG_PATH: Spring Boot의 logging.file.path(LOG_PATH)와 충돌 방지를 위해 별도 변수 사용
export JAVA_OPTS="$JAVA_OPTS -DICR_LOG_PATH=/opt/icr-solution/logs"
```

**logback-spring.xml 프로파일별 LOG_PATH 설정:**

```xml
<!-- local 프로파일: 로컬 개발용 고정 경로 -->
<springProfile name="local">
    <property name="LOG_PATH" value="logs/local"/>
    <!-- ... root level, appender 설정 ... -->
</springProfile>

<!-- dev/prod 프로파일: ICR_LOG_PATH 우선, 없으면 catalina.base/logs fallback -->
<springProfile name="dev">
    <property name="LOG_PATH" value="${ICR_LOG_PATH:-${catalina.base}/logs}"/>
    <!-- ... root level, appender 설정 ... -->
</springProfile>

<springProfile name="prod">
    <property name="LOG_PATH" value="${ICR_LOG_PATH:-${catalina.base}/logs}"/>
    <!-- ... root level, appender 설정 ... -->
</springProfile>
```

**환경별 로그 경로:**

| 환경 | 프로파일 | 로그 경로 |
|------|----------|-----------|
| 로컬 개발 | local | `logs/local/` (프로젝트 루트 기준) |
| icr-solution 설치 | dev, prod | `$INSTALL_BASE/logs/` (ICR_LOG_PATH 사용) |
| 수동 Tomcat 배포 | dev, prod | `$CATALINA_BASE/logs/` (fallback) |

**로그 파일 종류:**

| 로그 종류 | 위치 |
|-----------|------|
| 애플리케이션 로그 (Logback) | `${LOG_PATH}/icr-app.log` |
| 배치 로그 (Logback) | `${LOG_PATH}/icr-batch.log` |
| Tomcat 내부 로그 | `$TOMCAT_HOME/logs/catalina.out` |
| 액세스 로그 | `$TOMCAT_HOME/logs/localhost_access_log.*.txt` |

**변수 우선순위 (dev/prod 프로파일):**
1. `ICR_LOG_PATH` (setenv.sh) → icr-solution 설치 시 자동 설정
2. `${catalina.base}/logs` → 수동 Tomcat 배포 시 fallback


## 6. 다중 인스턴스

### 6-1. 포트 분리

동일 서버에서 여러 인스턴스를 운영하려면 포트를 분리합니다.

**인스턴스 1 (기본):**

```bash
WAS_HTTP_PORT=28080
WAS_HTTPS_PORT=28443
WAS_SHUTDOWN_PORT=8005
```

**인스턴스 2:**

```bash
WAS_HTTP_PORT=28081
WAS_HTTPS_PORT=28444
WAS_SHUTDOWN_PORT=8006
```

**인스턴스 3:**

```bash
WAS_HTTP_PORT=28082
WAS_HTTPS_PORT=28445
WAS_SHUTDOWN_PORT=8007
```

### 6-2. 디렉토리 분리

인스턴스별로 별도 디렉토리를 사용합니다.

```bash
# 인스턴스 1
INSTALL_BASE=/opt/icr-solution-1
TOMCAT_HOME=/opt/icr-solution-1/tomcat

# 인스턴스 2
INSTALL_BASE=/opt/icr-solution-2
TOMCAT_HOME=/opt/icr-solution-2/tomcat

# 인스턴스 3
INSTALL_BASE=/opt/icr-solution-3
TOMCAT_HOME=/opt/icr-solution-3/tomcat
```

**다중 인스턴스 설치 예시:**

```bash
# 인스턴스 1 설치
cd /opt/icr-solution-1
vi solution/config/site.conf  # 포트 및 경로 설정
./install.sh

# 인스턴스 2 설치
cd /opt/icr-solution-2
vi solution/config/site.conf  # 포트 및 경로 설정
./install.sh
```


## 7. CI/CD 연동

### 7-1. 배포 스크립트 옵션

CI/CD 파이프라인에서 사용하는 주요 옵션입니다.

```bash
# 외부 WAR 직접 배포 (packages/ 디렉토리 불필요)
./solution/bin/deploy-war.sh --war /path/to/icr.war

# 배포 + 헬스체크 (CI/CD 필수 권장)
./solution/bin/deploy-war.sh --war /path/to/icr.war --wait-health

# HTTPS 헬스체크 추가
./solution/bin/deploy-war.sh --war /path/to/icr.war --wait-health --check-https

# 헬스체크 재시도 설정
./solution/bin/deploy-war.sh --war /path/to/icr.war --wait-health --health-retry 10 --health-interval 5
```

| 옵션 | 설명 | 기본값 |
|------|------|--------|
| --war <경로> | 외부 WAR 파일 경로 | packages/icr.war |
| --wait-health | 배포 후 헬스체크 수행 | N |
| --check-https | HTTPS 헬스체크 추가 | N |
| --health-path <경로> | 헬스체크 URL 경로 | /icr/login |
| --health-retry <N> | 재시도 횟수 | 5 |
| --health-interval <초> | 재시도 간격 | 2 |
| --no-restart | 재기동 없이 WAR만 교체 | - |

### 7-2. GitLab CI 예시

```yaml
# .gitlab-ci.yml
variables:
  SERVER: "deploy@production-server"
  DEPLOY_PATH: "/opt/icr-solution"

stages:
  - build
  - deploy

build:
  stage: build
  script:
    - ./gradlew build
  artifacts:
    paths:
      - build/libs/*.war

deploy:
  stage: deploy
  script:
    - scp build/libs/icr.war $SERVER:/tmp/icr.war
    - ssh $SERVER "cd $DEPLOY_PATH && ./solution/bin/deploy-war.sh --war /tmp/icr.war --wait-health"
    - ssh $SERVER "rm /tmp/icr.war"
  only:
    - main
  environment:
    name: production
```

### 7-3. Jenkins Pipeline 예시

```groovy
// Jenkinsfile
pipeline {
    agent any

    environment {
        SERVER = 'deploy@production-server'
        DEPLOY_PATH = '/opt/icr-solution'
    }

    stages {
        stage('Build') {
            steps {
                sh './gradlew build'
            }
        }

        stage('Deploy') {
            steps {
                sh "scp build/libs/icr.war ${SERVER}:/tmp/icr.war"
                sh "ssh ${SERVER} 'cd ${DEPLOY_PATH} && ./solution/bin/deploy-war.sh --war /tmp/icr.war --wait-health'"
                sh "ssh ${SERVER} 'rm /tmp/icr.war'"
            }
        }
    }

    post {
        failure {
            echo 'Deployment failed!'
        }
        success {
            echo 'Deployment successful!'
        }
    }
}
```

### 7-4. 배포 결과 판단

deploy-war.sh는 종료 코드로 성공/실패를 반환합니다.

| 종료 코드 | 의미 |
|-----------|------|
| 0 | 배포 성공 |
| 1 | 배포 실패 (WAR 없음, 권한 오류 등) |
| 1 | 헬스체크 실패 (--wait-health 사용 시) |

CI/CD 파이프라인에서 종료 코드를 확인하여 배포 성공 여부를 판단합니다.

```bash
# 배포 후 결과 확인
./solution/bin/deploy-war.sh --war /tmp/icr.war --wait-health
if [ $? -eq 0 ]; then
    echo "배포 성공"
else
    echo "배포 실패"
    exit 1
fi
```


## 8. 공통 모듈 사용법

스크립트 개발 시 사용하는 공통 모듈들입니다.

### 8-1. logging.sh - 로깅 모듈

스크립트 실행 로그를 파일과 터미널에 동시 출력합니다.

**제공 함수:**

| 함수 | 설명 |
|------|------|
| `init_logging(script_name)` | 로그 파일 초기화 및 리다이렉션 설정 |
| `log(message)` | 타임스탬프 포함 로그 출력 |
| `die(error_message)` | 에러 메시지 출력 후 exit 1 |

**로그 파일 위치:**
```
solution/logs/{스크립트명}-{YYYYMMDD}.log
```

**사용 예시:**
```bash
#!/usr/bin/env bash
set -euo pipefail

# 경로 설정
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SOLUTION_HOME="$(cd "${SCRIPT_DIR}/.." && pwd)"

# 로깅 모듈 로드 및 초기화
source "${SOLUTION_HOME}/modules/logging.sh"
init_logging "my-script"

# 로그 출력
log "작업 시작"
log "변수값: ${SOME_VAR}"

# 에러 발생 시 종료
[[ -f "${FILE}" ]] || die "파일 없음: ${FILE}"
```

### 8-2. service_control.sh - 서비스 제어 모듈

Tomcat 서비스 시작/중지 및 site.conf 로드 기능을 제공합니다.

**제공 함수:**

| 함수 | 설명 |
|------|------|
| `load_site_conf(root_dir)` | site.conf 로드 및 필수 변수 검증 |
| `run(command)` | DRY_RUN 지원 명령 실행 |
| `is_running()` | Tomcat 실행 여부 확인 (0=실행중, 1=중지) |
| `svc_start()` | Tomcat 시작 (타임아웃 내 프로세스 감지) |
| `svc_stop()` | Tomcat 중지 (타임아웃 후 강제종료 옵션) |
| `svc_restart()` | svc_stop + svc_start |
| `svc_status()` | 상태 출력 (RUNNING/STOPPED) |
| `svc_diag()` | 진단 정보 출력 |
| `svc_tail(n)` | catalina.out 마지막 n줄 출력 |

**모듈 로딩 순서:**
```bash
# 반드시 logging.sh를 먼저 로드
source "${SOLUTION_HOME}/modules/logging.sh"
source "${SOLUTION_HOME}/modules/service_control.sh"
```

**사용 예시:**
```bash
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SOLUTION_HOME="$(cd "${SCRIPT_DIR}/.." && pwd)"
BASE_DIR="$(cd "${SOLUTION_HOME}/.." && pwd)"

# 모듈 로드 (순서 중요!)
source "${SOLUTION_HOME}/modules/logging.sh"
source "${SOLUTION_HOME}/modules/service_control.sh"

init_logging "my-script"

# site.conf 로드 (필수 변수 자동 검증)
load_site_conf "${BASE_DIR}"

# 진단 정보 출력
svc_diag

# 서비스 제어
if is_running; then
    log "이미 실행 중"
else
    svc_start
fi
```

**DRY_RUN 모드:**
```bash
# 실제 실행 없이 명령만 출력
DRY_RUN=Y ./solution/bin/deploy-war.sh
```


## 9. FAQ

### 9-1. 설정 변경 후 반영 방법

**site.conf 변경 후:**

1. 기존 설정 유지하며 재설치 (Tomcat만 재설치):
```bash
./uninstall.sh
./install.sh
```

2. 설정 파일 강제 재생성:
```bash
ICR_FORCE_REGEN=Y ./install.sh
```

3. 서비스만 재시작 (site.conf 변경이 JVM 옵션에만 해당하는 경우):
```bash
./solution/bin/stop.sh
./solution/bin/start.sh
```

### 9-2. 로그 확인 방법

**스크립트 실행 로그:**

모든 스크립트(install, start, stop, deploy-war 등)의 실행 로그가 `solution/logs/`에 저장됩니다.

```bash
# 스크립트 실행 로그 확인
ls -la solution/logs/
# install-20250115.log
# start-20250115.log
# deploy-war-20250115.log

# 설치 로그 확인
cat solution/logs/install-$(date +%Y%m%d).log
```

**Tomcat 로그:**

```bash
# 실시간 로그 확인
tail -f /opt/icr-solution/tomcat/logs/catalina.out

# 최근 500줄 확인
tail -500 /opt/icr-solution/tomcat/logs/catalina.out

# 에러만 필터링
grep -i error /opt/icr-solution/tomcat/logs/catalina.out | tail -100
```

**액세스 로그:**

```bash
# 오늘 액세스 로그
tail -f /opt/icr-solution/tomcat/logs/localhost_access_log.$(date +%Y-%m-%d).txt
```

**check.sh로 로그 확인:**

```bash
# 최근 100줄 출력
./solution/bin/check.sh --tail 100
```

### 9-3. 인증서 오류 해결

**증상: HTTPS 헬스체크 실패 (FAIL 000)**

```bash
# 인증서 파일 존재 확인
ls -la /opt/icr-solution/tomcat/conf/*.jks

# 인증서 정보 확인
keytool -list -v -keystore /opt/icr-solution/tomcat/conf/certificate.jks

# site.conf 설정 확인
grep -E 'WAS_SSL|WAS_ENABLE_HTTPS' solution/config/site.conf
```

**증상: 인증서 비밀번호 오류**

Tomcat 로그에서 다음과 같은 메시지가 나타납니다:
```
java.io.IOException: Keystore was tampered with, or password was incorrect
```

해결: site.conf의 WAS_SSL_KEYSTORE_PASSWORD가 인증서 생성 시 사용한 비밀번호와 일치하는지 확인합니다.

**증상: 인증서 만료**

```bash
# 인증서 만료일 확인
keytool -list -v -keystore /opt/icr-solution/tomcat/conf/certificate.jks | grep Valid
```

해결: 새 인증서를 발급받아 갱신합니다. (4-3. 인증서 갱신 참고)
